// Generated by gir (https://github.com/gtk-rs/gir @ b2a1c6f9b362)
// from ../misc (@ ???)
// DO NOT EDIT

use crate::{
    ActionDescription, AuthorityFeatures, AuthorizationResult, CheckAuthorizationFlags, Details,
    Identity, Subject, TemporaryAuthorization, ffi,
};
use glib::{
    object::ObjectType as _,
    prelude::*,
    signal::{SignalHandlerId, connect_raw},
    translate::*,
};
use std::{boxed::Box as Box_, pin::Pin};

glib::wrapper! {
    #[doc(alias = "PolkitAuthority")]
    pub struct Authority(Object<ffi::PolkitAuthority, ffi::PolkitAuthorityClass>);

    match fn {
        type_ => || ffi::polkit_authority_get_type(),
    }
}

impl Authority {
    #[doc(alias = "polkit_authority_authentication_agent_response")]
    pub fn authentication_agent_response<P: FnOnce(Result<(), glib::Error>) + 'static>(
        &self,
        cookie: &str,
        identity: &impl IsA<Identity>,
        cancellable: Option<&impl IsA<gio::Cancellable>>,
        callback: P,
    ) {
        let main_context = glib::MainContext::ref_thread_default();
        let is_main_context_owner = main_context.is_owner();
        let has_acquired_main_context = (!is_main_context_owner)
            .then(|| main_context.acquire().ok())
            .flatten();
        assert!(
            is_main_context_owner || has_acquired_main_context.is_some(),
            "Async operations only allowed if the thread is owning the MainContext"
        );

        let user_data: Box_<glib::thread_guard::ThreadGuard<P>> =
            Box_::new(glib::thread_guard::ThreadGuard::new(callback));
        unsafe extern "C" fn authentication_agent_response_trampoline<
            P: FnOnce(Result<(), glib::Error>) + 'static,
        >(
            _source_object: *mut glib::gobject_ffi::GObject,
            res: *mut gio::ffi::GAsyncResult,
            user_data: glib::ffi::gpointer,
        ) {
            let mut error = std::ptr::null_mut();
            unsafe {
                ffi::polkit_authority_authentication_agent_response_finish(
                    _source_object as *mut _,
                    res,
                    &mut error,
                );

                let result = if error.is_null() {
                    Ok(())
                } else {
                    Err(from_glib_full(error))
                };
                let callback: Box_<glib::thread_guard::ThreadGuard<P>> =
                    Box_::from_raw(user_data as *mut _);
                let callback: P = callback.into_inner();
                callback(result);
            }
        }
        let callback = authentication_agent_response_trampoline::<P>;
        unsafe {
            ffi::polkit_authority_authentication_agent_response(
                self.to_glib_none().0,
                cookie.to_glib_none().0,
                identity.as_ref().to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                Some(callback),
                Box_::into_raw(user_data) as *mut _,
            );
        }
    }

    pub fn authentication_agent_response_future(
        &self,
        cookie: &str,
        identity: &(impl IsA<Identity> + Clone + 'static),
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>> {
        let cookie = String::from(cookie);
        let identity = identity.clone();
        Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
            obj.authentication_agent_response(&cookie, &identity, Some(cancellable), move |res| {
                send.resolve(res);
            });
        }))
    }

    #[doc(alias = "polkit_authority_authentication_agent_response_sync")]
    pub fn authentication_agent_response_sync(
        &self,
        cookie: &str,
        identity: &impl IsA<Identity>,
        cancellable: Option<&impl IsA<gio::Cancellable>>,
    ) -> Result<(), glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::polkit_authority_authentication_agent_response_sync(
                self.to_glib_none().0,
                cookie.to_glib_none().0,
                identity.as_ref().to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                &mut error,
            );
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    #[doc(alias = "polkit_authority_check_authorization")]
    pub fn check_authorization<P: FnOnce(Result<AuthorizationResult, glib::Error>) + 'static>(
        &self,
        subject: &impl IsA<Subject>,
        action_id: &str,
        details: Option<&Details>,
        flags: CheckAuthorizationFlags,
        cancellable: Option<&impl IsA<gio::Cancellable>>,
        callback: P,
    ) {
        let main_context = glib::MainContext::ref_thread_default();
        let is_main_context_owner = main_context.is_owner();
        let has_acquired_main_context = (!is_main_context_owner)
            .then(|| main_context.acquire().ok())
            .flatten();
        assert!(
            is_main_context_owner || has_acquired_main_context.is_some(),
            "Async operations only allowed if the thread is owning the MainContext"
        );

        let user_data: Box_<glib::thread_guard::ThreadGuard<P>> =
            Box_::new(glib::thread_guard::ThreadGuard::new(callback));
        unsafe extern "C" fn check_authorization_trampoline<
            P: FnOnce(Result<AuthorizationResult, glib::Error>) + 'static,
        >(
            _source_object: *mut glib::gobject_ffi::GObject,
            res: *mut gio::ffi::GAsyncResult,
            user_data: glib::ffi::gpointer,
        ) {
            unsafe {
                let mut error = std::ptr::null_mut();
                let ret = ffi::polkit_authority_check_authorization_finish(
                    _source_object as *mut _,
                    res,
                    &mut error,
                );
                let result = if error.is_null() {
                    Ok(from_glib_full(ret))
                } else {
                    Err(from_glib_full(error))
                };
                let callback: Box_<glib::thread_guard::ThreadGuard<P>> =
                    Box_::from_raw(user_data as *mut _);
                let callback: P = callback.into_inner();
                callback(result);
            }
        }
        let callback = check_authorization_trampoline::<P>;
        unsafe {
            ffi::polkit_authority_check_authorization(
                self.to_glib_none().0,
                subject.as_ref().to_glib_none().0,
                action_id.to_glib_none().0,
                details.to_glib_none().0,
                flags.into_glib(),
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                Some(callback),
                Box_::into_raw(user_data) as *mut _,
            );
        }
    }

    pub fn check_authorization_future(
        &self,
        subject: &(impl IsA<Subject> + Clone + 'static),
        action_id: &str,
        details: Option<&Details>,
        flags: CheckAuthorizationFlags,
    ) -> Pin<
        Box_<dyn std::future::Future<Output = Result<AuthorizationResult, glib::Error>> + 'static>,
    > {
        let subject = subject.clone();
        let action_id = String::from(action_id);
        let details = details.map(ToOwned::to_owned);
        Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
            obj.check_authorization(
                &subject,
                &action_id,
                details.as_ref().map(::std::borrow::Borrow::borrow),
                flags,
                Some(cancellable),
                move |res| {
                    send.resolve(res);
                },
            );
        }))
    }

    #[doc(alias = "polkit_authority_check_authorization_sync")]
    pub fn check_authorization_sync(
        &self,
        subject: &impl IsA<Subject>,
        action_id: &str,
        details: Option<&Details>,
        flags: CheckAuthorizationFlags,
        cancellable: Option<&impl IsA<gio::Cancellable>>,
    ) -> Result<AuthorizationResult, glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let ret = ffi::polkit_authority_check_authorization_sync(
                self.to_glib_none().0,
                subject.as_ref().to_glib_none().0,
                action_id.to_glib_none().0,
                details.to_glib_none().0,
                flags.into_glib(),
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                &mut error,
            );
            if error.is_null() {
                Ok(from_glib_full(ret))
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    #[doc(alias = "polkit_authority_enumerate_actions")]
    pub fn enumerate_actions<P: FnOnce(Result<Vec<ActionDescription>, glib::Error>) + 'static>(
        &self,
        cancellable: Option<&impl IsA<gio::Cancellable>>,
        callback: P,
    ) {
        let main_context = glib::MainContext::ref_thread_default();
        let is_main_context_owner = main_context.is_owner();
        let has_acquired_main_context = (!is_main_context_owner)
            .then(|| main_context.acquire().ok())
            .flatten();
        assert!(
            is_main_context_owner || has_acquired_main_context.is_some(),
            "Async operations only allowed if the thread is owning the MainContext"
        );

        let user_data: Box_<glib::thread_guard::ThreadGuard<P>> =
            Box_::new(glib::thread_guard::ThreadGuard::new(callback));
        unsafe extern "C" fn enumerate_actions_trampoline<
            P: FnOnce(Result<Vec<ActionDescription>, glib::Error>) + 'static,
        >(
            _source_object: *mut glib::gobject_ffi::GObject,
            res: *mut gio::ffi::GAsyncResult,
            user_data: glib::ffi::gpointer,
        ) {
            unsafe {
                let mut error = std::ptr::null_mut();
                let ret = ffi::polkit_authority_enumerate_actions_finish(
                    _source_object as *mut _,
                    res,
                    &mut error,
                );
                let result = if error.is_null() {
                    Ok(FromGlibPtrContainer::from_glib_full(ret))
                } else {
                    Err(from_glib_full(error))
                };
                let callback: Box_<glib::thread_guard::ThreadGuard<P>> =
                    Box_::from_raw(user_data as *mut _);
                let callback: P = callback.into_inner();
                callback(result);
            }
        }
        let callback = enumerate_actions_trampoline::<P>;
        unsafe {
            ffi::polkit_authority_enumerate_actions(
                self.to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                Some(callback),
                Box_::into_raw(user_data) as *mut _,
            );
        }
    }

    pub fn enumerate_actions_future(
        &self,
    ) -> Pin<
        Box_<
            dyn std::future::Future<Output = Result<Vec<ActionDescription>, glib::Error>> + 'static,
        >,
    > {
        Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
            obj.enumerate_actions(Some(cancellable), move |res| {
                send.resolve(res);
            });
        }))
    }

    #[doc(alias = "polkit_authority_enumerate_actions_sync")]
    pub fn enumerate_actions_sync(
        &self,
        cancellable: Option<&impl IsA<gio::Cancellable>>,
    ) -> Result<Vec<ActionDescription>, glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let ret = ffi::polkit_authority_enumerate_actions_sync(
                self.to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                &mut error,
            );
            if error.is_null() {
                Ok(FromGlibPtrContainer::from_glib_full(ret))
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    #[doc(alias = "polkit_authority_enumerate_temporary_authorizations")]
    pub fn enumerate_temporary_authorizations<
        P: FnOnce(Result<Vec<TemporaryAuthorization>, glib::Error>) + 'static,
    >(
        &self,
        subject: &impl IsA<Subject>,
        cancellable: Option<&impl IsA<gio::Cancellable>>,
        callback: P,
    ) {
        let main_context = glib::MainContext::ref_thread_default();
        let is_main_context_owner = main_context.is_owner();
        let has_acquired_main_context = (!is_main_context_owner)
            .then(|| main_context.acquire().ok())
            .flatten();
        assert!(
            is_main_context_owner || has_acquired_main_context.is_some(),
            "Async operations only allowed if the thread is owning the MainContext"
        );

        let user_data: Box_<glib::thread_guard::ThreadGuard<P>> =
            Box_::new(glib::thread_guard::ThreadGuard::new(callback));
        unsafe extern "C" fn enumerate_temporary_authorizations_trampoline<
            P: FnOnce(Result<Vec<TemporaryAuthorization>, glib::Error>) + 'static,
        >(
            _source_object: *mut glib::gobject_ffi::GObject,
            res: *mut gio::ffi::GAsyncResult,
            user_data: glib::ffi::gpointer,
        ) {
            unsafe {
                let mut error = std::ptr::null_mut();
                let ret = ffi::polkit_authority_enumerate_temporary_authorizations_finish(
                    _source_object as *mut _,
                    res,
                    &mut error,
                );
                let result = if error.is_null() {
                    Ok(FromGlibPtrContainer::from_glib_full(ret))
                } else {
                    Err(from_glib_full(error))
                };
                let callback: Box_<glib::thread_guard::ThreadGuard<P>> =
                    Box_::from_raw(user_data as *mut _);
                let callback: P = callback.into_inner();
                callback(result);
            }
        }
        let callback = enumerate_temporary_authorizations_trampoline::<P>;
        unsafe {
            ffi::polkit_authority_enumerate_temporary_authorizations(
                self.to_glib_none().0,
                subject.as_ref().to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                Some(callback),
                Box_::into_raw(user_data) as *mut _,
            );
        }
    }

    pub fn enumerate_temporary_authorizations_future(
        &self,
        subject: &(impl IsA<Subject> + Clone + 'static),
    ) -> Pin<
        Box_<
            dyn std::future::Future<Output = Result<Vec<TemporaryAuthorization>, glib::Error>>
                + 'static,
        >,
    > {
        let subject = subject.clone();
        Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
            obj.enumerate_temporary_authorizations(&subject, Some(cancellable), move |res| {
                send.resolve(res);
            });
        }))
    }

    #[doc(alias = "polkit_authority_enumerate_temporary_authorizations_sync")]
    pub fn enumerate_temporary_authorizations_sync(
        &self,
        subject: &impl IsA<Subject>,
        cancellable: Option<&impl IsA<gio::Cancellable>>,
    ) -> Result<Vec<TemporaryAuthorization>, glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let ret = ffi::polkit_authority_enumerate_temporary_authorizations_sync(
                self.to_glib_none().0,
                subject.as_ref().to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                &mut error,
            );
            if error.is_null() {
                Ok(FromGlibPtrContainer::from_glib_full(ret))
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    #[doc(alias = "polkit_authority_get_backend_features")]
    #[doc(alias = "get_backend_features")]
    #[doc(alias = "backend-features")]
    pub fn backend_features(&self) -> AuthorityFeatures {
        unsafe {
            from_glib(ffi::polkit_authority_get_backend_features(
                self.to_glib_none().0,
            ))
        }
    }

    #[doc(alias = "polkit_authority_get_backend_name")]
    #[doc(alias = "get_backend_name")]
    #[doc(alias = "backend-name")]
    pub fn backend_name(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::polkit_authority_get_backend_name(
                self.to_glib_none().0,
            ))
        }
    }

    #[doc(alias = "polkit_authority_get_backend_version")]
    #[doc(alias = "get_backend_version")]
    #[doc(alias = "backend-version")]
    pub fn backend_version(&self) -> glib::GString {
        unsafe {
            from_glib_none(ffi::polkit_authority_get_backend_version(
                self.to_glib_none().0,
            ))
        }
    }

    #[doc(alias = "polkit_authority_get_owner")]
    #[doc(alias = "get_owner")]
    pub fn owner(&self) -> Option<glib::GString> {
        unsafe { from_glib_full(ffi::polkit_authority_get_owner(self.to_glib_none().0)) }
    }

    #[doc(alias = "polkit_authority_register_authentication_agent")]
    pub fn register_authentication_agent<P: FnOnce(Result<(), glib::Error>) + 'static>(
        &self,
        subject: &impl IsA<Subject>,
        locale: &str,
        object_path: &str,
        cancellable: Option<&impl IsA<gio::Cancellable>>,
        callback: P,
    ) {
        let main_context = glib::MainContext::ref_thread_default();
        let is_main_context_owner = main_context.is_owner();
        let has_acquired_main_context = (!is_main_context_owner)
            .then(|| main_context.acquire().ok())
            .flatten();
        assert!(
            is_main_context_owner || has_acquired_main_context.is_some(),
            "Async operations only allowed if the thread is owning the MainContext"
        );

        let user_data: Box_<glib::thread_guard::ThreadGuard<P>> =
            Box_::new(glib::thread_guard::ThreadGuard::new(callback));
        unsafe extern "C" fn register_authentication_agent_trampoline<
            P: FnOnce(Result<(), glib::Error>) + 'static,
        >(
            _source_object: *mut glib::gobject_ffi::GObject,
            res: *mut gio::ffi::GAsyncResult,
            user_data: glib::ffi::gpointer,
        ) {
            unsafe {
                let mut error = std::ptr::null_mut();
                ffi::polkit_authority_register_authentication_agent_finish(
                    _source_object as *mut _,
                    res,
                    &mut error,
                );
                let result = if error.is_null() {
                    Ok(())
                } else {
                    Err(from_glib_full(error))
                };
                let callback: Box_<glib::thread_guard::ThreadGuard<P>> =
                    Box_::from_raw(user_data as *mut _);
                let callback: P = callback.into_inner();
                callback(result);
            }
        }
        let callback = register_authentication_agent_trampoline::<P>;
        unsafe {
            ffi::polkit_authority_register_authentication_agent(
                self.to_glib_none().0,
                subject.as_ref().to_glib_none().0,
                locale.to_glib_none().0,
                object_path.to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                Some(callback),
                Box_::into_raw(user_data) as *mut _,
            );
        }
    }

    pub fn register_authentication_agent_future(
        &self,
        subject: &(impl IsA<Subject> + Clone + 'static),
        locale: &str,
        object_path: &str,
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>> {
        let subject = subject.clone();
        let locale = String::from(locale);
        let object_path = String::from(object_path);
        Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
            obj.register_authentication_agent(
                &subject,
                &locale,
                &object_path,
                Some(cancellable),
                move |res| {
                    send.resolve(res);
                },
            );
        }))
    }

    #[doc(alias = "polkit_authority_register_authentication_agent_sync")]
    pub fn register_authentication_agent_sync(
        &self,
        subject: &impl IsA<Subject>,
        locale: &str,
        object_path: &str,
        cancellable: Option<&impl IsA<gio::Cancellable>>,
    ) -> Result<(), glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::polkit_authority_register_authentication_agent_sync(
                self.to_glib_none().0,
                subject.as_ref().to_glib_none().0,
                locale.to_glib_none().0,
                object_path.to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                &mut error,
            );
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    #[doc(alias = "polkit_authority_register_authentication_agent_with_options")]
    pub fn register_authentication_agent_with_options<
        P: FnOnce(Result<(), glib::Error>) + 'static,
    >(
        &self,
        subject: &impl IsA<Subject>,
        locale: &str,
        object_path: &str,
        options: Option<&glib::Variant>,
        cancellable: Option<&impl IsA<gio::Cancellable>>,
        callback: P,
    ) {
        let main_context = glib::MainContext::ref_thread_default();
        let is_main_context_owner = main_context.is_owner();
        let has_acquired_main_context = (!is_main_context_owner)
            .then(|| main_context.acquire().ok())
            .flatten();
        assert!(
            is_main_context_owner || has_acquired_main_context.is_some(),
            "Async operations only allowed if the thread is owning the MainContext"
        );

        let user_data: Box_<glib::thread_guard::ThreadGuard<P>> =
            Box_::new(glib::thread_guard::ThreadGuard::new(callback));
        unsafe extern "C" fn register_authentication_agent_with_options_trampoline<
            P: FnOnce(Result<(), glib::Error>) + 'static,
        >(
            _source_object: *mut glib::gobject_ffi::GObject,
            res: *mut gio::ffi::GAsyncResult,
            user_data: glib::ffi::gpointer,
        ) {
            unsafe {
                let mut error = std::ptr::null_mut();
                ffi::polkit_authority_register_authentication_agent_with_options_finish(
                    _source_object as *mut _,
                    res,
                    &mut error,
                );
                let result = if error.is_null() {
                    Ok(())
                } else {
                    Err(from_glib_full(error))
                };
                let callback: Box_<glib::thread_guard::ThreadGuard<P>> =
                    Box_::from_raw(user_data as *mut _);
                let callback: P = callback.into_inner();
                callback(result);
            }
        }
        let callback = register_authentication_agent_with_options_trampoline::<P>;
        unsafe {
            ffi::polkit_authority_register_authentication_agent_with_options(
                self.to_glib_none().0,
                subject.as_ref().to_glib_none().0,
                locale.to_glib_none().0,
                object_path.to_glib_none().0,
                options.to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                Some(callback),
                Box_::into_raw(user_data) as *mut _,
            );
        }
    }

    pub fn register_authentication_agent_with_options_future(
        &self,
        subject: &(impl IsA<Subject> + Clone + 'static),
        locale: &str,
        object_path: &str,
        options: Option<&glib::Variant>,
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>> {
        let subject = subject.clone();
        let locale = String::from(locale);
        let object_path = String::from(object_path);
        let options = options.map(ToOwned::to_owned);
        Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
            obj.register_authentication_agent_with_options(
                &subject,
                &locale,
                &object_path,
                options.as_ref().map(::std::borrow::Borrow::borrow),
                Some(cancellable),
                move |res| {
                    send.resolve(res);
                },
            );
        }))
    }

    #[doc(alias = "polkit_authority_register_authentication_agent_with_options_sync")]
    pub fn register_authentication_agent_with_options_sync(
        &self,
        subject: &impl IsA<Subject>,
        locale: &str,
        object_path: &str,
        options: Option<&glib::Variant>,
        cancellable: Option<&impl IsA<gio::Cancellable>>,
    ) -> Result<(), glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::polkit_authority_register_authentication_agent_with_options_sync(
                self.to_glib_none().0,
                subject.as_ref().to_glib_none().0,
                locale.to_glib_none().0,
                object_path.to_glib_none().0,
                options.to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                &mut error,
            );
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    #[doc(alias = "polkit_authority_revoke_temporary_authorization_by_id")]
    pub fn revoke_temporary_authorization_by_id<P: FnOnce(Result<(), glib::Error>) + 'static>(
        &self,
        id: &str,
        cancellable: Option<&impl IsA<gio::Cancellable>>,
        callback: P,
    ) {
        let main_context = glib::MainContext::ref_thread_default();
        let is_main_context_owner = main_context.is_owner();
        let has_acquired_main_context = (!is_main_context_owner)
            .then(|| main_context.acquire().ok())
            .flatten();
        assert!(
            is_main_context_owner || has_acquired_main_context.is_some(),
            "Async operations only allowed if the thread is owning the MainContext"
        );

        let user_data: Box_<glib::thread_guard::ThreadGuard<P>> =
            Box_::new(glib::thread_guard::ThreadGuard::new(callback));
        unsafe extern "C" fn revoke_temporary_authorization_by_id_trampoline<
            P: FnOnce(Result<(), glib::Error>) + 'static,
        >(
            _source_object: *mut glib::gobject_ffi::GObject,
            res: *mut gio::ffi::GAsyncResult,
            user_data: glib::ffi::gpointer,
        ) {
            unsafe {
                let mut error = std::ptr::null_mut();
                ffi::polkit_authority_revoke_temporary_authorization_by_id_finish(
                    _source_object as *mut _,
                    res,
                    &mut error,
                );
                let result = if error.is_null() {
                    Ok(())
                } else {
                    Err(from_glib_full(error))
                };
                let callback: Box_<glib::thread_guard::ThreadGuard<P>> =
                    Box_::from_raw(user_data as *mut _);
                let callback: P = callback.into_inner();
                callback(result);
            }
        }
        let callback = revoke_temporary_authorization_by_id_trampoline::<P>;
        unsafe {
            ffi::polkit_authority_revoke_temporary_authorization_by_id(
                self.to_glib_none().0,
                id.to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                Some(callback),
                Box_::into_raw(user_data) as *mut _,
            );
        }
    }

    pub fn revoke_temporary_authorization_by_id_future(
        &self,
        id: &str,
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>> {
        let id = String::from(id);
        Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
            obj.revoke_temporary_authorization_by_id(&id, Some(cancellable), move |res| {
                send.resolve(res);
            });
        }))
    }

    #[doc(alias = "polkit_authority_revoke_temporary_authorization_by_id_sync")]
    pub fn revoke_temporary_authorization_by_id_sync(
        &self,
        id: &str,
        cancellable: Option<&impl IsA<gio::Cancellable>>,
    ) -> Result<(), glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::polkit_authority_revoke_temporary_authorization_by_id_sync(
                self.to_glib_none().0,
                id.to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                &mut error,
            );
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    #[doc(alias = "polkit_authority_revoke_temporary_authorizations")]
    pub fn revoke_temporary_authorizations<P: FnOnce(Result<(), glib::Error>) + 'static>(
        &self,
        subject: &impl IsA<Subject>,
        cancellable: Option<&impl IsA<gio::Cancellable>>,
        callback: P,
    ) {
        let main_context = glib::MainContext::ref_thread_default();
        let is_main_context_owner = main_context.is_owner();
        let has_acquired_main_context = (!is_main_context_owner)
            .then(|| main_context.acquire().ok())
            .flatten();
        assert!(
            is_main_context_owner || has_acquired_main_context.is_some(),
            "Async operations only allowed if the thread is owning the MainContext"
        );

        let user_data: Box_<glib::thread_guard::ThreadGuard<P>> =
            Box_::new(glib::thread_guard::ThreadGuard::new(callback));
        unsafe extern "C" fn revoke_temporary_authorizations_trampoline<
            P: FnOnce(Result<(), glib::Error>) + 'static,
        >(
            _source_object: *mut glib::gobject_ffi::GObject,
            res: *mut gio::ffi::GAsyncResult,
            user_data: glib::ffi::gpointer,
        ) {
            unsafe {
                let mut error = std::ptr::null_mut();
                ffi::polkit_authority_revoke_temporary_authorizations_finish(
                    _source_object as *mut _,
                    res,
                    &mut error,
                );
                let result = if error.is_null() {
                    Ok(())
                } else {
                    Err(from_glib_full(error))
                };
                let callback: Box_<glib::thread_guard::ThreadGuard<P>> =
                    Box_::from_raw(user_data as *mut _);
                let callback: P = callback.into_inner();
                callback(result);
            }
        }
        let callback = revoke_temporary_authorizations_trampoline::<P>;
        unsafe {
            ffi::polkit_authority_revoke_temporary_authorizations(
                self.to_glib_none().0,
                subject.as_ref().to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                Some(callback),
                Box_::into_raw(user_data) as *mut _,
            );
        }
    }

    pub fn revoke_temporary_authorizations_future(
        &self,
        subject: &(impl IsA<Subject> + Clone + 'static),
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>> {
        let subject = subject.clone();
        Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
            obj.revoke_temporary_authorizations(&subject, Some(cancellable), move |res| {
                send.resolve(res);
            });
        }))
    }

    #[doc(alias = "polkit_authority_revoke_temporary_authorizations_sync")]
    pub fn revoke_temporary_authorizations_sync(
        &self,
        subject: &impl IsA<Subject>,
        cancellable: Option<&impl IsA<gio::Cancellable>>,
    ) -> Result<(), glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::polkit_authority_revoke_temporary_authorizations_sync(
                self.to_glib_none().0,
                subject.as_ref().to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                &mut error,
            );
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    #[doc(alias = "polkit_authority_unregister_authentication_agent")]
    pub fn unregister_authentication_agent<P: FnOnce(Result<(), glib::Error>) + 'static>(
        &self,
        subject: &impl IsA<Subject>,
        object_path: &str,
        cancellable: Option<&impl IsA<gio::Cancellable>>,
        callback: P,
    ) {
        let main_context = glib::MainContext::ref_thread_default();
        let is_main_context_owner = main_context.is_owner();
        let has_acquired_main_context = (!is_main_context_owner)
            .then(|| main_context.acquire().ok())
            .flatten();
        assert!(
            is_main_context_owner || has_acquired_main_context.is_some(),
            "Async operations only allowed if the thread is owning the MainContext"
        );

        let user_data: Box_<glib::thread_guard::ThreadGuard<P>> =
            Box_::new(glib::thread_guard::ThreadGuard::new(callback));
        unsafe extern "C" fn unregister_authentication_agent_trampoline<
            P: FnOnce(Result<(), glib::Error>) + 'static,
        >(
            _source_object: *mut glib::gobject_ffi::GObject,
            res: *mut gio::ffi::GAsyncResult,
            user_data: glib::ffi::gpointer,
        ) {
            unsafe {
                let mut error = std::ptr::null_mut();
                ffi::polkit_authority_unregister_authentication_agent_finish(
                    _source_object as *mut _,
                    res,
                    &mut error,
                );
                let result = if error.is_null() {
                    Ok(())
                } else {
                    Err(from_glib_full(error))
                };
                let callback: Box_<glib::thread_guard::ThreadGuard<P>> =
                    Box_::from_raw(user_data as *mut _);
                let callback: P = callback.into_inner();
                callback(result);
            }
        }
        let callback = unregister_authentication_agent_trampoline::<P>;
        unsafe {
            ffi::polkit_authority_unregister_authentication_agent(
                self.to_glib_none().0,
                subject.as_ref().to_glib_none().0,
                object_path.to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                Some(callback),
                Box_::into_raw(user_data) as *mut _,
            );
        }
    }

    pub fn unregister_authentication_agent_future(
        &self,
        subject: &(impl IsA<Subject> + Clone + 'static),
        object_path: &str,
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>> {
        let subject = subject.clone();
        let object_path = String::from(object_path);
        Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
            obj.unregister_authentication_agent(
                &subject,
                &object_path,
                Some(cancellable),
                move |res| {
                    send.resolve(res);
                },
            );
        }))
    }

    #[doc(alias = "polkit_authority_unregister_authentication_agent_sync")]
    pub fn unregister_authentication_agent_sync(
        &self,
        subject: &impl IsA<Subject>,
        object_path: &str,
        cancellable: Option<&impl IsA<gio::Cancellable>>,
    ) -> Result<(), glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::polkit_authority_unregister_authentication_agent_sync(
                self.to_glib_none().0,
                subject.as_ref().to_glib_none().0,
                object_path.to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                &mut error,
            );
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    #[doc(alias = "polkit_authority_get")]
    pub fn get() -> Authority {
        unsafe { from_glib_full(ffi::polkit_authority_get()) }
    }

    #[doc(alias = "polkit_authority_get_async")]
    #[doc(alias = "get_async")]
    pub fn async_<P: FnOnce(Result<Authority, glib::Error>) + 'static>(
        cancellable: Option<&impl IsA<gio::Cancellable>>,
        callback: P,
    ) {
        let main_context = glib::MainContext::ref_thread_default();
        let is_main_context_owner = main_context.is_owner();
        let has_acquired_main_context = (!is_main_context_owner)
            .then(|| main_context.acquire().ok())
            .flatten();
        assert!(
            is_main_context_owner || has_acquired_main_context.is_some(),
            "Async operations only allowed if the thread is owning the MainContext"
        );

        let user_data: Box_<glib::thread_guard::ThreadGuard<P>> =
            Box_::new(glib::thread_guard::ThreadGuard::new(callback));
        unsafe extern "C" fn async__trampoline<
            P: FnOnce(Result<Authority, glib::Error>) + 'static,
        >(
            _source_object: *mut glib::gobject_ffi::GObject,
            res: *mut gio::ffi::GAsyncResult,
            user_data: glib::ffi::gpointer,
        ) {
            unsafe {
                let mut error = std::ptr::null_mut();
                let ret = ffi::polkit_authority_get_finish(res, &mut error);
                let result = if error.is_null() {
                    Ok(from_glib_full(ret))
                } else {
                    Err(from_glib_full(error))
                };
                let callback: Box_<glib::thread_guard::ThreadGuard<P>> =
                    Box_::from_raw(user_data as *mut _);
                let callback: P = callback.into_inner();
                callback(result);
            }
        }
        let callback = async__trampoline::<P>;
        unsafe {
            ffi::polkit_authority_get_async(
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                Some(callback),
                Box_::into_raw(user_data) as *mut _,
            );
        }
    }

    pub fn async__future()
    -> Pin<Box_<dyn std::future::Future<Output = Result<Authority, glib::Error>> + 'static>> {
        Box_::pin(gio::GioFuture::new(&(), move |_obj, cancellable, send| {
            Self::async_(Some(cancellable), move |res| {
                send.resolve(res);
            });
        }))
    }

    #[doc(alias = "polkit_authority_get_sync")]
    #[doc(alias = "get_sync")]
    pub fn sync(
        cancellable: Option<&impl IsA<gio::Cancellable>>,
    ) -> Result<Authority, glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let ret = ffi::polkit_authority_get_sync(
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                &mut error,
            );
            if error.is_null() {
                Ok(from_glib_full(ret))
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    #[doc(alias = "changed")]
    pub fn connect_changed<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn changed_trampoline<F: Fn(&Authority) + 'static>(
            this: *mut ffi::PolkitAuthority,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(&from_glib_borrow(this))
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"changed".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    changed_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "sessions-changed")]
    pub fn connect_sessions_changed<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn sessions_changed_trampoline<F: Fn(&Authority) + 'static>(
            this: *mut ffi::PolkitAuthority,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(&from_glib_borrow(this))
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"sessions-changed".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    sessions_changed_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "backend-features")]
    pub fn connect_backend_features_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_backend_features_trampoline<F: Fn(&Authority) + 'static>(
            this: *mut ffi::PolkitAuthority,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(&from_glib_borrow(this))
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::backend-features".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_backend_features_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "backend-name")]
    pub fn connect_backend_name_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_backend_name_trampoline<F: Fn(&Authority) + 'static>(
            this: *mut ffi::PolkitAuthority,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(&from_glib_borrow(this))
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::backend-name".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_backend_name_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "backend-version")]
    pub fn connect_backend_version_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_backend_version_trampoline<F: Fn(&Authority) + 'static>(
            this: *mut ffi::PolkitAuthority,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(&from_glib_borrow(this))
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::backend-version".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_backend_version_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "owner")]
    pub fn connect_owner_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_owner_trampoline<F: Fn(&Authority) + 'static>(
            this: *mut ffi::PolkitAuthority,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(&from_glib_borrow(this))
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::owner".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_owner_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }
}
